ifeval::[{docname}=='GuideTutoriaMarkedGraph']
:toc:
:toclevels: 4
:numbered:
:tabsize: 4
endif::[]



= GEMOC xDSML definition tutorial with MarkedGraph

TODO: Provide .as, .as.edit, .as.editor.


== Overview / What is expected at the end of this tutorial

This tutorial aims at demonstrating the power of the GEMOC studio to
define an executable semantics and provide graphical animation for a
DSML.   It relies of the
http://en.wikipedia.org/wiki/Marked_graph[marked graph] language.

TODO: Show an animated GIF or a video.

NOTE: A screencast of this tutorial can be found here (give URL when
it will be available)...

Please, read the link:GuideQuickTutorial.html[introduction of tutorials] to
understand the GEMOC approach to define executable DSML or to have a
better understanding of the abbreviations used in this tutorial.


== Install the projects defining the Marked Graph AS and CS

=== Import the Marked Graph AS and CS

Marked Graph is a kind of
http://en.wikipedia.org/wiki/Petri_net[Petri net]
in which every place has exactly one incoming arc and exactly one
outgoing arc.  As a consequence, it a concurrent language (several
transitions may be fired) and has no conflict.


=== Abstract Syntax

The Domain Model, also called Abstract Syntax or Metamodel, defines :

- A __marked graph__ as a set of __places__ and __transitions__.
- Each __Place__ has exactly one __input__ transition and one __output__
transition and a token count.
- A transition has several __input__ places and several __output__
  places.

[[MarkedGraph-AS]]
.Abstract Syntax (Metamodel) of MarkedGraph
image::MarkedGraph/images/MarkedGraph-AS.png[MarkedGraph Domain Model (Metamodel)]

=== Concrete Syntax and Sample Model

TODO: Take a capture form Wikipedia.

The one of Wikipedia?
Another one ?


== Set up an xDSML project

In this section, we first create an xDSML project for MarkedGraph
and initialize it with the provided Abstract Syntax (AS) and Concrete
Syntax (CS).

=== Create an xDSML Project

Create a new xDSML project (__New > Project > GEMOC
Project / new xDSML Project__), with the desired name (for instance
__org.gemoc.example.markedgraph__).

TODO: Add a screenshot

=== Open xDSML View 

A file __project.xml__ has been created.  When opened, it provides the xDSML
view which summarizes all the important resources used in an xDSML
project (which are part of and managed by other projects).  This view
is a kind of dashboard or control center to have quick access to any
important resource of the project.

TODO: Add a screenshot

=== Select the AS

In the "Domain Model" section, click on the "Browse" button to select
the project defining the AS: org.gemoc.markedgraph.as.

TODO: Required?
Then, initialize the "Genmodel URI" and the "Root container model
element".

TODO: Add a screenshot.



=== Select the Graphical Editor

The Graphical Editor defines a graphical concrete syntax which is
user-friendly to view and edit a model.

In the "Concrete syntax definition / Graphical editor" of the
project.xdsml editor, click on "Browse" to select the
"org.gemoc.markedgraph.design" project.

TODO : Add a screncast.



== Define the Execution Semantics

// === Execution Semantics Overview

XXX: à déplacer dans MoCC ou DSE ?

A transition can be fired if there is at least one token in every of
each entry place.  When fired, one token is removed from each of its entry
place and one token is added to each of its output place.

// XXX déjà dit ?

During execution of a MarkedGraph, the number of tokens of a place has
to be recorded and changed according to the fired transitions.  Thus,
we have to manage an execution data (ED) called runtimeTokenCount and
an execution function (EF) on Transition called fire().  Furthermore,
the runtimeTokenCount of each place must be initialized at the start
of the execution. It is the purpose of the EF called initialize() on
the MarkedGraph element.


=== Define DSA

When executing a Marked Graph model, we want to know the number of
token of each place (it is an ED).  When transition are fired (EF),
one token is removed from each input places and one token is added to
each output places.

The DSA of Marked Graph is composed of :

* one ED called  __runtimeTokenCount__
defined on __Place__ . It represents the number of token in a place when the
model is executed.
* one EF called initialize() defined
on __MarkedGraph__. It initializes the runtime token count of each
place with the initial token count.
* one ED called __fire()__ on
__Transition__. It to remove one token from each of its input places
and add one token to all its output places.


==== Create the DSA Project

Click on __K3 project__ in the project.xdml editor (Behavioral definition / DSA
definition).  The wizard to create of new Kermeta 3 project is
launched with the name of the project initialized (k3dsa is the last
name). Click "Finish".  The project has been created.

==== Implement the DSA

Clicking again on _K3 project_ will now open markedgraph.xtend.  It
has been initialized with a template that can be discarded and
replaced with the following text.

[source]
----
include::MarkedGraph/markedgraph.xtend[DSA defined using K3]
----

==== Create the Extented Model with Melange

Note: This step should become transparent in a next version of the
GEMOC Stutio.

XXX: What is the status of Melange.  How it works?



=== Define DSE

The purpose of the DSE project is to define events (called DSE) on AS
elements that will trigger EF calls when they occurs.  Furthermore,
constraints can be defined on these events to ensure they occur in the
right order.
// XXX: wording must be improved?


==== Create the DSE Project

To create the DSE Project, click on the "ECL Project" in the
project.xdsml editor ("Behavior definition / DSE definition").
Click "finish" and the project is created.

TODO: To be completed?


==== Define DSE

This step has three main purposes:

* First, it specifies DSE in the context of metaclasses of the AS.
* Then, it links them to EF form DSA --- when a DSE will occurs the
associated EF will be executed.
* Finally, it defines constraints on the DSE to rule the possible
scheduling.  Constraints generally rely on relations which are defined
in the MoCC.

WARNING: Errors are present because the used Relations are not yet
defined...  They will be solved during the next step of this tutorial.


NOTE: Please notice that, as often, DSE are defined at the language
level, but at runtime they are instantiated as MSE on each object
instance of the metaclasse they are defined on.  In the same way,
constraints apply to the MSE.

Click on "ECL Project" to edit the "markedgraph.ecl" file and replace
its content with the following:

[source]
.The file markedgraph.ecl
----
include::MarkedGraph/markedgraph.ecl[Definition of the MoCC]
----

TODO: Separate the MoCC part.  We could define several relations :
onlyOnce, beforeAll, and delayedPrecede.

TODO: Say that the Precede relation is defined in kernel.ccslLib or
CCSL.ccslLib.


TODO: Give some rationals on the relation and their instancitions. In
particular the delay.

What should be explained?

- The main principles (we can fire as much transition has the initial
token count of a place, thus a delayed is introduce)
- We want to ensure that one init is done before any fire (and only
once)


Provide a pointer to a MoCCML version which uses constraint automata
to define the MoCC.


=== Define MoCC



Give the implementation of the relations used in the DSE.

MoCCLib... To be done...

TODO: How to explain the defined relation?

TODO: Add a link to another tutorial which uses an automata to define
the MoCC.

Tricks: Limitation of ECL for Integer type : use of a local
expression.



=== Define Animation Viewpoint

One wants to know the number of tokens in any place during the
execution.  For example, it can be shown as a number inside the circle
representing a place and the size of the circle can be proportional to
the number of tokens it contains.

% XXX: Fireable transitions may be drawn in green.  


As the animation view is close to the graphical concrete syntax, we
extend the existing diagram description.

==== Extend the existing diagram description

TODO: Explain...

XXX: In Which eclipse?

TODO: The aird has to be provided!

Add a link to a tutorial for Sirius Animator.


== Animate a Model

The executable MarkedGraph Language is now defined.  We can use the
GEMOC Modeling Workbench to execute MarkedGraph models.

=== Launch the Modelling WorkBench

Launch the Modeling Workbench by running a new Eclipse:  right
click, select "run as / Eclipse Application".  The new eclipse is the
Modeling Workbench.

=== Import the project with a sample model

Import the modeling project org.gemoc.markedgraph.sample in the
Modeling Workbench (Import / General / Existing project into
Workspace).

=== Create a Launch Configuration

Create a Run Configuration: right click on the model and select "Run
As... > Run Configurations". Create a new "Gemoc eXecutable Model"
configuration.  We can call it "gemoc" and fill in the fields:
Model to execute: "first.automata", xDSML: "markedgraph".

Change the "Decider" to "Step by step user decider" (the user will
decide which is the next step to execute).

=== Start the model

We can now run the "gemoc" configuration.  The graphical
representation is opened, the VCD is created, etc.

TODO: Give some explanations.


=== Select a logical step

From the timeline view, select the step to execute.

TODO: To complete...


=== What else?

Any idea?


== Questions/Remarks...

Questions on the MoCC from summerSchool :

- why delayedBy p.initialMarking and not delayedBy 1?
	=> Because we can make as much read as there is initialMarking
	token in the place.  Any write in that place, means that a new
	read can be done.

- is it still right if the initial marking is P2 = 1 (all other places
is 0) ?
	=> No. But in any case, this initialMarking will result in a
	deadlock.

- what if there is several places which are initially marked?
	=> See read/write semantics


Questions on the implementation :

- A transition has no more that one input or output place.  Should be
any number !

Questions:

- use execute for the EF on transition instead of fire and use fire
(or trigger) for the DSE instead of fireCall.


Questions on the form :

- Use of abbreviations like MoCC, DSA, EF, ED, AS, CS, etc.? Yes
because using the full name will make the tutorial hard to read.
=> Explanations of acronyms must be provided somewhere.
- Avoid to split files in several parts?  For example ED and EF are
defined in the same files.  It is thus useless to try to have two
steps, one to define the ED and the other to define EF.
- How to name the project defining the abstract syntax? model or as?
=> If 'as' or 'metamodel' is used, then the wizard should be changed
in order to avoid to have the language named 'as' or 'metamodel'.


TODO :

- Remove "example" in the name of the project?
- DONE: Domain model and then MetaModel (Abstract Syntax)
- Give insight on the debugging, tricks to resolve problms, etC. => A
kind of FAQ must be provided.
- Look at the Mélanie's Dashboard so that the steps in the tutorial
corresponds to activities in the dashboard.
- Look at the tools guide written by Didier, Florent et Issa.


Tips and tricks :

* When the Ecore is changed to add new operations (and the genmodel is
used to regenerate the projects), the ECL editor keep signaling errors
concerning the unresolved operations.  The solution consists in
closing the editor and opening again the ECL file.



// vim: set syntax=asciidoc tw=70 ts=4 sw=4:
// vim: spell spelllang=en:
