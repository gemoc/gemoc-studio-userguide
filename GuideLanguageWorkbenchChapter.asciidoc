== GEMOC Language Workbench image:images/icons/IconeGemocLanguage_16.png[width=16, height=16, role=right]

=== Overview

The *((GEMOC Language Workbench))* is intended to be used by the ((Language Designer))s and the ((Language Integrator))s. It provides the tools to create and compose eXecutable Domain-Specific Modeling Languages (xDSMLs) using the GEMOC approach.

[[figure-glw-screenshot-of-language_workbench]]
.Screenshot of the GEMOC Language Workbench showing the design of a Timed Finite State Machine (TFSM) example.
image::images/gemoc_language_workbench_TFSM_screenshot.png[Screenshot of the GEMOC Language Workbench]
(((TFSM,Language Workbench)))

'''
[[section-gemoc-language-project]]
=== xDSML Project

==== Purpose
The xDSML Project is the core project of languages created using the GEMOC Studio. It has two main purposes:

* Referencing the different projects representing the various parts constituting an xDSML;

* Guiding the ((Language Designer)) in the language creation process through the ((GEMOC Dashboard)) illustrating the workflow of creating an xDSML using the GEMOC Studio.

==== Creating the xDSML Project
In the GEMOC Studio, go to: _File > New > Project... > New GEMOC Language Project_. This will create a new xDSML Project in your workspace.

==== Editing the xDSML Project
The main file constituting the xDSML Project is the _project.xdsml_. To edit this file, open it with the "XDSML Model Editor".

From the information specified in this file, the project generates additional code that is used by the Execution Engine during the execution of models conforming to the xDSML (see <<chapter-gemoc-modeling-workbench>>).   

[[section-define-AS-project]]
=== Domain Model Project

==== Purpose
The Domain Model Project specifies the concepts of the domain at hand and the structural relations between the concepts.

==== Creating the Domain Model Project
The GEMOC Studio relies on the Eclipse Modeling Framework for its Domain Model Projects. See http://eclipse.org/modeling/emf/[the EMF website] for more information on how to create an EMF project in Eclipse. The Domain Model is materialized as an Ecore metamodel.

When your EMF Project is done, connect your xDSML Project to it by specifying in the _project.xdsml_ file the name of the EMF Project, the path to the genmodel of your Ecore metamodel and the name of the root element as _package::root_.

TODO: Melange?

==== Editing the Domain Model Project
If you wish to modify your Domain Model, do not forget to reload the associated genmodel and regenerate the EMF model code (and edit/editor code if you use them).

[[section-define-dsa-project]]
=== Defining the Domain-Specific Actions (DSA) Project

==== Purpose
The Domain-Specific Actions define the runtime state (*Execution Data*) of the model and the operations (*Execution Functions*) which modify the runtime state of the model.

==== Creating the DSA Project
In the GEMOC Studio, the DSA are implemented using https://github.com/diverse-project/k3/wiki[Kermeta 3].
To create a new DSA Project, in the main menu of the GEMOC Studio, go to: _File > New > Project... > K3 Project_. In the wizard, create it as a Plug-in with EMF using the template of your choice.
Then, connect the xDSML Project to the DSA Project by referencing the DSA Project in the _project.xdsml_ file.

==== Editing the DSA Project
Kermeta 3 is based on http://www.eclipse.org/xtend/index.html[xTend]. The Execution Data and Execution Functions are defined through aspects weaved onto the metaclasses of the Domain Model.

===== Defining the Execution Data
The Execution Data consist in attributes and references added to existing concepts (metaclasses) of the Abstract Syntax. They may also include new metaclasses which define the type of these new attributes and references.

===== Defining the Execution Functions
The Execution Functions define how the Execution Data evolve during the execution of the model. Execution Functions can be implemented by defining the body of a method.

[NOTE]
For now, Execution Functions are considered as *atomic, instantaneous and blocking*. This means that any long computation will block the rest of the simulation, and concurrent Execution Functions are not executed in concurrence yet.

[NOTE]
For technical reasons, the Domain Model (Ecore metamodel) must specify the signature of the Execution Functions as EOperations.

==== Testing the Domain-Specific Actions
It is possible to test the DSA (in particular the Execution Functions) by simply writing a simple program with a _main_ function (using Java or Xtend/Kermeta3). Create or load a model conform to your Domain Model and call the Execution Functions in the right order to verify there are no runtime exceptions or domain issues.

=== Defining Domain-Specific Constraints
TODO

=== Defining a Concrete Syntax
An xDSML can support different concrete syntaxes. Most EMF-based editors should work with GEMOC, however the GEMOC Studio provides additional support for some specific editors. Thus, we recommend using: an EMF arborescent editor, an Xtext editor, and/or a Sirius editor.
Don't forget to link the xDSML Project to the concrete syntax project(s) you want to use by editing the _project.xdsml_ file.

==== Defining a Concrete Syntax with Xtext
See http://www.eclipse.org/Xtext/[the Xtext website].

==== Defining a Concrete Syntax with ((Sirius))
If you want to create a graphical concrete syntax you can use Sirius. The http://www.eclipse.org/sirius/doc/[Sirius documentation] provides information for http://www.eclipse.org/sirius/doc/specifier/Sirius%20Specifier%20Manual.html[Sirius Specifier Manual].

=== Defining a Model of Concurrency and Communication (MoCC)
TODO: MoccML + ECL

=== Defining the Domain-Specific Events (DSE)

==== Purpose
The DSE define a mapping between MoccEvents from the MoCC and the Execution Functions. They specify the coordination between what happens in the MoCC, depending on its constraints, and which operations must be called in the model (thus resulting in changes in the Execution Data).

==== Creating the DSE Project
Create an empty Plug-in Project. In this project, create a new file with the ".GEL" extension. The DSE can be defined using the *Gemoc Events Language* (GEL).

==== Editing the DSE Project
The first step to designing the DSE in GEL consists in importing the MoCC2AS Mapping (ECL file) and the Domain Model (Ecore metamodel) of the xDSML. You can do so by using the "import platform:/plugin/..." syntax at the beginning of the file.

Then a DSE is defined using the following syntax:
----
DSE <name>:
  upon <MoccEvent>
  triggers <Path-to-ExecutionFunction>
end
----
After the _upon_ keyword, any MoccEvent from the MoCC2AS Mapping can be referenced. After the 'triggers' keyword, navigation path from the context of the MoccEvent to an EOperation can be defined to specify which Execution Function must be triggered by this Domain-Specific Event.

[Note]
The implicit context of a Domain-Specific Event is inferred from the context in which its associated MoccEvent is defined in the MoCC2AS Mapping. Therefore, the DSE will be usable for any instance in the model of the context of the DSE. For instance if a DSE is mapped to a MoccEvent defined in the context of the metaclass _Transition_, and there are 3 Transitions in the model being executed, this DSE will be usable for each of the 3 Transitions of the model.

==== Example
----
import "platform:/plugin/org.gemoc.sample.fuml.model/model/fuml.ecore"
import "platform:/plugin/org.gemoc.sample.fuml.mocc/ECL/fuml.ecl"

DSE ExecuteActivityNode:
	upon mocc_executeNode
	triggers ActivityNode.execute
end
----

=== Defining the Feedback Specification

==== Purpose
In the GEMOC approach, the MoCC is independent from the domain. However, most languages need to be able to parameterize their control flow with their data flow. For instance, a conditional statement is a control flow construct which is conditioned by the result of its condition. Therefore, a form of communication between the MoCC and the DSA must be operated.
In this context, the Feedback Specification specifies how domain data returned by an Execution Function must be interpreted to parameterize the MoCC. The Feedback Specification consists in a set of Feedback Policies which are associated to the Domain-Specific Events. Therefore, the Feedback Specification is also done using ((GEL)).

==== Creating a Feedback Policy
A Feedback Policy can be associated to a DSE using the following syntax:
----
import "platform:/plugin/org.gemoc.sample.fuml.model/model/fuml.ecore"
import "platform:/plugin/org.gemoc.sample.fuml.mocc/ECL/fuml.ecl"

DSE <name>:
  upon <MoccEvent>
  triggers <Path-to-ExecutionFunction> returning <resultName>
  feedback:
    [<filter1>] => allow <PathToMoccEventConsequence1>
    [<filter2>] => allow <PathToMoccEventConsequence2>
    ...
    default => allow <PathToMoccEventDefaultConsequence>
  end
end
----
Where:

* <resultName> is a local variable which will be affected with the value returned by the associated Execution Function;

* Between the _feedback_ and _end_ keywords, a set of Feedback Rules are defined (including a default Feedback Rule, with the _default_ keyword). A Feedback Rule is composed of a filter and a consequence;

* <filterN> are predicates, most likely using <resultName> which define whether or not this Feedback Rule must be applied;

* <PathToMoccEventConsequenceN> is a navigation path to a MoccEvent which specifies which MoccEvent is allowed as a result of the data returned by the Execution Function.

==== Semantics of the Feedback Policy
When the Execution Function associated to a DSE returns a result, it is passed through each filter of the Feedback Policy. If none of the filters is validated, then the default rule is applied. Else, the collection of rules for which the filter validated are applied. 
For each rule to apply, the associated consequence is allowed to have occurrences in upcoming steps of execution.

==== Example
----
DSE EvaluateGuard:
	upon mocc_evaluateGuard
	triggers ActivityEdge.evaluateGuard returning result
	feedback:
		[ result ] => allow ActivityEdge.mocc_mayExecuteTarget
		default => allow ActivityEdge.mocc_mayNotExecuteTarget
	end
end
----



=== Defining a debug view
The debug layer is an extension on top of a graphical editor defined with ((Sirius)) that represent runtime data and current instruction. See <<Defining a concrete syntax with ((Sirius))>> for more details about ((Sirius)). This section will cover the debug representation creation wizard and technical implementation details. Technical implementation details are only useful for advanced use case and troubleshooting.

==== The debug representation wizard
This wizard creates a layer to represent the current instruction and add commands to manage break points and launch a simulation in debug mode. This is a default implementation, it can be customized to represent runtime data for instance. The customization use the ((Sirius)) description definition, see the http://www.eclipse.org/sirius/doc/specifier/Sirius%20Specifier%20Manual.html[Sirius Specifier Manual] for more details.
The wizard present three ways of implementing this layer:

* Create a debug diagram description
* Extends an existing diagram description
* Add a debug layer to an existing diagram description

===== Create a debug diagram description
It creates a diagram representation with a default debug layer. The representation do not depend on an other representation. A typical use case is a language where the runtime data representation is too far from the language graphical syntax.

image::images/workbench/language/debug_representation_wizard/wizard.png[Debug representation wizard]

===== Extend an existing diagram description
It creates a diagram representation with a default debug layer that extends an existing representation. This allow to have a debug layer based on the representation of the language concrete syntax. The language concrete syntax can be deployed without the debug representation. A typical use case is the reuse of an existing diagram definition that you can't modify yourself. For instance if you want to use http://eclipse.org/modeling/mdt/?project=uml2[UML], you can reuse the http://www.umldesigner.org/[UML Designer].

image::images/workbench/language/debug_representation_wizard/create/1.png[Debug representation wizard]

image::images/workbench/language/debug_representation_wizard/create/2.png[Debug representation wizard]

===== Add a debug layer to an existing diagram description
It creates a default debug layer in an existing diagram representation. This should be used if you are also in charge of the language concrete syntax.

image::images/workbench/language/debug_representation_wizard/extend/1.png[Debug representation wizard]

You can select any diagram description.

image::images/workbench/language/debug_representation_wizard/extend/2.png[Debug representation wizard]

image::images/workbench/language/debug_representation_wizard/extend/3.png[Debug representation wizard]

==== Implementation details
Implementation details are for advanced use and troubleshooting. It explains how the implementation works behind the scene. There are two main elements covered here are the debugger services class and the debug layer itself.

image::images/workbench/language/debug_representation_wizard/add/1.png[Debug representation wizard]

You can only select a diagram description from the workspace.

image::images/workbench/language/debug_representation_wizard/add/2.png[Debug representation wizard]

===== Debugger services
The debugger services class is use to tell which representations should be activated and refreshed during debug (see the getRepresentationRefreshList() method). It also provide a method to know if an element of the diagram is the current instruction (see isCurrentInstruction() method).

image::images/workbench/language/debug_services.png[Debug services]

===== Debug layer
The default debug layer add action to start the simulation in debug mode and to toggle breakpoints (1). When a break point is present for an element of the diagram a visual feedback is displayed according to the breakpoint state (2). The current instruction is also highlighted in yellow by default (3)

image::images/workbench/language/debug_layer.png[Debug layer]

This is a default debug layer, it can be customized to fit your needs. The customization use the ((Sirius)) description definition, see the http://www.eclipse.org/sirius/doc/specifier/Sirius%20Specifier%20Manual.html[Sirius Specifier Manual] for more details.

[[section-process-support-view]]
=== Process support view

TODO present process view
